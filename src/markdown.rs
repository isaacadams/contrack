use anyhow::Result;
use std::collections::HashMap;

use crate::database::{Commit, Contribution};

pub fn generate_markdown(
    repo_url: &str,
    contributions: &[(Contribution, Vec<Commit>)],
    author_filter: Option<&str>,
) -> Result<String> {
    let mut output = String::new();

    // Header
    output.push_str("# Contributions\n\n");
    output.push_str(&format!(
        "This document provides a comprehensive overview of all contributions for this repository.\n\n"
    ));
    output.push_str(&format!("**Repository:** {}\n\n", repo_url));
    output.push_str("---\n\n");

    // Group by category
    let mut by_category: HashMap<String, Vec<&(Contribution, Vec<Commit>)>> = HashMap::new();
    for contrib in contributions {
        by_category
            .entry(contrib.0.category.clone())
            .or_insert_with(Vec::new)
            .push(contrib);
    }

    // Sort categories by priority of first contribution
    let mut categories: Vec<_> = by_category.iter().collect();
    categories.sort_by_key(|(_, contribs)| {
        contribs
            .iter()
            .map(|(c, _)| c.priority)
            .max()
            .unwrap_or(0)
    });
    categories.reverse();

    // Generate sections
    for (category, contribs) in categories {
        output.push_str(&format!("## {}\n\n", category));
        output.push_str(&format!("### Overview\n\n"));
        output.push_str(&format!(
            "This section contains {} contribution(s) in the {} category.\n\n",
            contribs.len(),
            category
        ));
        output.push_str("---\n\n");

        // Sort contributions by priority
        let mut sorted_contribs = contribs.clone();
        sorted_contribs.sort_by_key(|(c, _)| c.priority);
        sorted_contribs.reverse();

        for (contrib, commits) in sorted_contribs {
            // Filter commits by author if specified
            let filtered_commits: Vec<&Commit> = if let Some(author) = author_filter {
                commits
                    .iter()
                    .filter(|c| c.author.contains(author))
                    .collect()
            } else {
                commits.iter().collect()
            };

            if author_filter.is_some() && filtered_commits.is_empty() {
                continue;
            }

            output.push_str(&format!("### {}\n\n", contrib.name));
            output.push_str(&format!("**Category:** {} | **Priority:** {}\n\n", 
                                   contrib.category, contrib.priority));
            output.push_str(&format!("{}\n\n", contrib.overview));
            output.push_str(&format!("{}\n\n", contrib.description));

            // Key commits
            if !contrib.key_commits.is_empty() {
                output.push_str("#### Key Commits\n\n");
                for commit_hash in &contrib.key_commits {
                    if let Some(commit) = filtered_commits.iter().find(|c| c.hash.starts_with(commit_hash)) {
                        output.push_str(&format!("- **{}** - {}\n", 
                                                commit.hash[..8].to_string(), 
                                                commit.message.lines().next().unwrap_or("")));
                        output.push_str(&format!("  - Author: {} ({})\n", commit.author, commit.date));
                    } else {
                        output.push_str(&format!("- {}\n", commit_hash));
                    }
                }
                output.push_str("\n");
            }

            // Technical details
            if !contrib.technical_details.is_empty() {
                output.push_str("#### Technical Details\n\n");
                for (key, value) in &contrib.technical_details {
                    output.push_str(&format!("- **{}**: {}\n", key, value));
                }
                output.push_str("\n");
            }

            // Resume bullets
            if !contrib.resume_bullets.is_empty() {
                output.push_str("#### Resume Bullet Points\n\n");
                for bullet in &contrib.resume_bullets {
                    output.push_str(&format!("- {}\n", bullet));
                }
                output.push_str("\n");
            }

            output.push_str("---\n\n");
        }
    }

    // Footer
    output.push_str("## Summary\n\n");
    output.push_str(&format!(
        "Total contributions documented: {}\n\n",
        contributions.len()
    ));

    if let Some(author) = author_filter {
        output.push_str(&format!("*Filtered by author: {}*\n", author));
    }

    output.push_str("\n---\n\n");
    output.push_str("*This document was generated by contrack.*\n");

    Ok(output)
}

